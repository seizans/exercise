####################################
リンカローダ実践開発テクニックを読む
####################################

0章
===

何を学ぶ本か

- リンカとローダ
- オブジェクトフォーマット(の1つであるELF形式)
- 各種ツールの使い方と解析の仕方
- ハックのやり方

なぜこれを読むのか

- カーネルコールを呼ぶ周辺で必要なのでは
- ダンプなどバイナリを読む方法が必要そう
- 「BSDなどのカーネルのソースはリンカのテクニックを駆使した書き方をされていることも多い」そうなので

※ FreeBSD 4.10、GNUプロジェクトのgccとbinutils を前提としている

1章
===

.. list-table::
   :header-rows: 1

   * - 形式
     - 操作
   * - ソースコード
     - 
   * - ↓
     - コンパイル
   * - オブジェクトファイル
     - 
   * - ↓
     - リンク
   * - 実行形式
     -
   * - ↓
     - ロード
   * - (実行)
     - 

CPU が実行できるのはメインメモリ(CPU上の?)上の実行コードのみ。
実行形式をメインメモリに展開することが「ロード」。

リンカの仕事
============

リンカの仕事は、コンパイラが出力したコード(機械語)を、OS依存の実行形式に変換すること。

ソースコードを実行形式に変換する処理はコンパイルとリンクに分けられている。
分割した理由は、コンパイルをファイルごとにやりたいから。(1ファイルの変更で全ファイルをコンパイルしたくない)

- コンパイルはソースコードファイルごとに可能

しかし他のファイルの関数を使うのはどうするのか？という疑問がある。
コンパイル時は処理の実体ではなく「○○というファイルの△△関数を呼び出す」というマークをしておく。
リンク時にそのマークを実体(実行できる命令)にする。
なお、これはライブラリ関数を使うにもリンカが必要ということも意味する。

システム・コールの呼び出しはアセンブリ言語で書かれている(だいたい)。
ということでシステム・コールを呼ぶ箇所もリンク時に実体にする必要がある。

実は実行形式を作成するには「スタートアップルーチン」というプログラムや「_exit()」というシステム・コールをリンクする必要もあり、リンクは必須。

実行形式とセクション
====================

オブジェクトフォーマットはELF(Executable and Linking Format)形式。
このフォーマットの対象は、オブジェクトファイル、実行形式、DLL。
ELF形式以外では、以前はa.out形式、一部ではCOFF形式もある。

実行形式では、a.out の時代から、ファイルが3つの領域に分けられている。
size コマンドで確認できる。

:text: 実行コード、const変数、文字列リテラル
:data: 書き込み可能な変数
:bss(Block Started by Symbol): 初期値が未定義の変数

ELF形式では、より多くの領域に分割している。
分割された領域の単位をセクションと呼ぶ。
objdump -h コマンドで、実行形式のセクションを確認できる。


VMA(Virtual Memory Address) と LMA(Load Memory Address) の違いわかりません・・・

シンボルと再配置
================

ローダの仕事
============

OSがローダの役割を持つ。
execve() システム・コールが呼ばれるとOSが実行形式をロードする。
execve() はアプリケーション(何の？)が呼ぶ。

リンカスクリプト
================

ELF形式のセクションは弄れる。(新規追加したり、フラグ付加したりなど)
方法は、

- コマンドラインオプションで指定する
- リンカスクリプト(リンク用設定ファイル)を変更する
